use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

const BINDING_SOURCE: &str = r#"// @generated by autheo-pqc-wasm/build.rs
// Minimal JavaScript helper for the pqc_alloc/pqc_free/pqc_handshake ABI.

const textEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder() : null;

function toUint8(value) {
  if (value instanceof Uint8Array) {
    return value;
  }

  if (typeof value === "string") {
    if (!textEncoder) {
      throw new Error("TextEncoder is not available in this environment.");
    }
    return textEncoder.encode(value);
  }

  if (ArrayBuffer.isView(value)) {
    return new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
  }

  if (value instanceof ArrayBuffer) {
    return new Uint8Array(value);
  }

  throw new TypeError("Unsupported request payload; pass Uint8Array, string, or ArrayBuffer.");
}

function memoryView(memory) {
  return new Uint8Array(memory.buffer);
}

async function instantiate(source) {
  if (source && source.instance instanceof WebAssembly.Instance) {
    return source.instance;
  }

  if (source instanceof WebAssembly.Instance) {
    return source;
  }

  if (source instanceof WebAssembly.Module) {
    return new WebAssembly.Instance(source, {});
  }

  const input = source ?? "./autheo_pqc_wasm.wasm";

  if (
    typeof input === "string" ||
    (typeof URL !== "undefined" && input instanceof URL) ||
    (typeof Request !== "undefined" && input instanceof Request)
  ) {
    if (typeof fetch !== "function") {
      throw new Error("fetch() is not available; provide a Response, ArrayBuffer, or module instead.");
    }
    const response = await fetch(input);
    return instantiate(response);
  }

  if (typeof Response !== "undefined" && input instanceof Response) {
    if (WebAssembly.instantiateStreaming) {
      const { instance } = await WebAssembly.instantiateStreaming(input, {});
      return instance;
    }
    const bytes = await input.arrayBuffer();
    const { instance } = await WebAssembly.instantiate(bytes, {});
    return instance;
  }

  const buffer =
    input instanceof ArrayBuffer
      ? input
      : ArrayBuffer.isView(input)
      ? input.buffer
      : null;

  if (buffer) {
    const { instance } = await WebAssembly.instantiate(buffer, {});
    return instance;
  }

  throw new TypeError("Unsupported WebAssembly source.");
}

export async function initPqcNet(source, options = {}) {
  const instance = await instantiate(source);
  const { memory, pqc_alloc, pqc_free, pqc_handshake } = instance.exports;

  if (
    !memory ||
    typeof pqc_alloc !== "function" ||
    typeof pqc_free !== "function" ||
    typeof pqc_handshake !== "function"
  ) {
    throw new Error("autheo_pqc_wasm is missing required exports.");
  }

  const responseCapacity = options.responseCapacity ?? 4096;

  function handshake(payload) {
    const requestBytes = toUint8(payload);
    const mem = memoryView(memory);

    const reqPtr = pqc_alloc(requestBytes.length);
    if (reqPtr === 0) {
      throw new Error("pqc_alloc failed while preparing request buffer.");
    }
    mem.set(requestBytes, reqPtr);

    const respPtr = pqc_alloc(responseCapacity);
    if (respPtr === 0) {
      pqc_free(reqPtr, requestBytes.length);
      throw new Error("pqc_alloc failed while preparing response buffer.");
    }

    const written = pqc_handshake(
      reqPtr,
      requestBytes.length,
      respPtr,
      responseCapacity
    );
    pqc_free(reqPtr, requestBytes.length);

    if (written < 0) {
      pqc_free(respPtr, responseCapacity);
      throw new Error(`pqc_handshake failed with code ${written}`);
    }

    const output = mem.slice(respPtr, respPtr + written);
    pqc_free(respPtr, responseCapacity);
    return output;
  }

  return {
    instance,
    memory,
    handshake,
  };
}
"#;

fn main() {
  println!("cargo:rerun-if-env-changed=CARGO_TARGET_DIR");
  println!("cargo:rerun-if-env-changed=PROFILE");
  println!("cargo:rerun-if-changed=build.rs");

  let target = env::var("TARGET").unwrap_or_default();
  if !target.contains("wasm32") {
    return;
  }

  let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("manifest dir"));
  let target_dir = env::var("CARGO_TARGET_DIR")
      .map(PathBuf::from)
      .unwrap_or_else(|_| manifest_dir.join("..").join("target"));
  let profile = env::var("PROFILE").unwrap_or_else(|_| "debug".to_string());
  let output_dir = target_dir.join(&target).join(&profile);

  ensure_dir(&output_dir);
  write_bindings(&output_dir.join("pqcnet.js"));
}

fn ensure_dir(dir: &Path) {
  if let Err(err) = fs::create_dir_all(dir) {
    panic!("failed to create bindings directory {}: {err}", dir.display());
  }
}

fn write_bindings(path: &Path) {
  let mut file = fs::File::create(path)
      .unwrap_or_else(|err| panic!("failed to create {}: {err}", path.display()));
  file
      .write_all(BINDING_SOURCE.as_bytes())
      .unwrap_or_else(|err| panic!("failed to write {}: {err}", path.display()));
}
